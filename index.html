<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flashcards with Input</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Optional: nicer focus ring */
    input:focus, select:focus, button:focus { outline: 2px solid #000; outline-offset: 2px; }
    code { background:#f4f4f5; padding:0 .25rem; border-radius:.25rem; }
  </style>
</head>
<body class="bg-gray-50 p-6">
  <div class="max-w-3xl mx-auto">
    <h1 class="text-3xl font-bold mb-4">Flashcards with Input</h1>

    <!-- Add / Import / Export -->
    <section class="bg-white p-4 rounded-xl shadow mb-6">
      <h2 class="font-semibold mb-3">Add a Card</h2>
      <div class="grid gap-2">
        <input id="front" class="w-full border rounded p-2" placeholder="Front (e.g., 日)">
        <input id="back" class="w-full border rounded p-2" placeholder="Back (answer to type, e.g., sun, day)">
        <input id="example" class="w-full border rounded p-2" placeholder="Example (optional, e.g., 日本 (にほん) – Japan)">
        <label class="flex items-center gap-2 text-sm">
          <input type="checkbox" id="reverse" checked> Also create reverse card
        </label>
        <div class="flex gap-2">
          <button id="addBtn" class="px-4 py-2 rounded bg-black text-white">Add</button>

          <label class="px-4 py-2 rounded bg-gray-100 border cursor-pointer">
            Import JSON
            <input id="importFile" type="file" accept="application/json" class="hidden">
          </label>

          <button id="exportBtn" class="px-4 py-2 rounded bg-gray-900 text-white">Export JSON</button>
        </div>
        <p class="text-xs text-gray-500">
          JSON format:
          <code>[{"front":"日","back":"sun, day","example":"日本 (にほん) – Japan"}]</code>
        </p>
      </div>
    </section>

    <!-- Review -->
    <section class="bg-white p-4 rounded-xl shadow mb-6">
      <div class="flex items-center gap-3 mb-3">
        <span class="text-sm">Direction:</span>
        <select id="mode" class="border rounded px-2 py-1 text-sm">
          <option value="front">Front → Back</option>
          <option value="back">Back → Front</option>
          <option value="mixed" selected>Mixed</option>
        </select>
        <button id="startBtn" class="ml-auto px-4 py-2 rounded bg-black text-white">Start / Shuffle</button>
      </div>

      <div id="cardArea" class="hidden">
        <div class="text-sm text-gray-500 mb-1">
          Cards left: <span id="leftCount">0</span>
        </div>
        <div id="prompt" class="text-2xl font-semibold mb-3"></div>

        <input id="answerInput" class="w-full border rounded p-2 mb-2"
               placeholder="Type your answer… (Enter = Check / Next)">
        <div id="result" class="mt-3"></div>
      </div>
    </section>

    <!-- Card List -->
    <section class="bg-white p-4 rounded-xl shadow">
      <div class="flex items-center gap-3 mb-2">
        <h2 class="font-semibold">Your Cards</h2>
        <button id="clearBtn" class="ml-auto text-xs underline">Clear all (reset)</button>
      </div>
      <ul id="cardList" class="text-sm space-y-1"></ul>
    </section>
  </div>

<script>
/* ------------------ Storage & State ------------------ */
let cards = JSON.parse(localStorage.getItem("cards") || "[]");
// If no cards exist in localStorage, auto-load kanji.json
if (!localStorage.getItem("cards")) {
  fetch("kanji.json")
    .then(res => res.json())
    .then(data => {
      cards = data;
      save();
      renderList();
    })
    .catch(err => console.error("Error loading default deck:", err));
}
let queue = [];          // indices in shuffled order
let current = null;      // current index into cards
let currentSide = "front";
let lastChecked = false; // Enter behavior

function save() {
  localStorage.setItem("cards", JSON.stringify(cards));
  renderList();
}

/* ------------------ Helpers ------------------ */
function normalize(s) {
  return (s || "").trim().toLowerCase().replace(/\s+/g, " ");
}
function splitAnswers(s) {
  // Accept any of these separators for multiple correct answers
  return (s || "")
    .split(/[,;/]|(?:\s+or\s+)/i)
    .map(a => normalize(a))
    .filter(Boolean);
}
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ------------------ UI Rendering ------------------ */
const listEl = document.getElementById("cardList");
const promptEl = document.getElementById("prompt");
const resultEl = document.getElementById("result");
const leftEl = document.getElementById("leftCount");
const inputEl = document.getElementById("answerInput");

function renderList() {
  listEl.innerHTML = "";
  if (!cards.length) {
    listEl.innerHTML = '<li class="text-gray-500">No cards yet. Add or import above.</li>';
    return;
  }
  cards.forEach((c, i) => {
    const li = document.createElement("li");
    li.className = "flex justify-between items-center gap-2";
    const ex = c.example ? ` <span class="text-gray-500">| ${c.example}</span>` : "";
    li.innerHTML = `
      <span>${i+1}. <b>${c.front}</b> → ${c.back}${ex}</span>
    `;
    listEl.appendChild(li);
  });
}
renderList();

/* ------------------ Add / Import / Export ------------------ */
document.getElementById("addBtn").addEventListener("click", () => {
  const f = document.getElementById("front").value.trim();
  const b = document.getElementById("back").value.trim();
  const e = document.getElementById("example").value.trim();
  const rev = document.getElementById("reverse").checked;
  if (!f || !b) return;

  cards.push({ front: f, back: b, example: e || undefined });
  if (rev) {
    cards.push({ front: b, back: f, example: e ? `${f} → ${e}` : undefined });
  }
  document.getElementById("front").value = "";
  document.getElementById("back").value = "";
  document.getElementById("example").value = "";
  save();
});

document.getElementById("importFile").addEventListener("change", (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      if (Array.isArray(data)) {
        // Validate and clean
        const cleaned = data
          .filter(x => x && typeof x.front === "string" && typeof x.back === "string")
          .map(x => ({ front: x.front, back: x.back, example: x.example }));
        cards = cleaned;
        save();
        alert(`Imported ${cleaned.length} cards.`);
      } else {
        alert("JSON should be an array of {front, back, example?} objects.");
      }
    } catch (err) {
      alert("Invalid JSON file.");
    }
    e.target.value = "";
  };
  reader.readAsText(file);
});

document.getElementById("exportBtn").addEventListener("click", () => {
  const blob = new Blob([JSON.stringify(cards, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "flashcards.json";
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById("clearBtn").addEventListener("click", () => {
  if (!confirm("Clear all saved cards? This cannot be undone.")) return;
  cards = [];
  save();
});

/* ------------------ Review Flow ------------------ */
document.getElementById("startBtn").addEventListener("click", startReview);

function startReview() {
  if (!cards.length) {
    alert("No cards yet. Add or import a deck first.");
    return;
  }
  queue = shuffle([...Array(cards.length).keys()]);
  document.getElementById("cardArea").classList.remove("hidden");
  nextCard();
  inputEl.focus();
}

function nextCard() {
  if (!queue.length) {
    // reshuffle when queue is empty
    queue = shuffle([...Array(cards.length).keys()]);
  }
  current = queue.shift();
  leftEl.textContent = queue.length;
  const mode = document.getElementById("mode").value;
  currentSide = (mode === "mixed") ? (Math.random() < 0.5 ? "front" : "back") : mode;

  const shown = currentSide === "front" ? cards[current].front : cards[current].back;
  promptEl.textContent = shown;
  inputEl.value = "";
  resultEl.innerHTML = "";
  lastChecked = false;
}

function checkAnswer() {
  if (current === null) return;
  const rawExpected = currentSide === "front" ? cards[current].back : cards[current].front;
  const expectedList = splitAnswers(rawExpected);
  const user = normalize(inputEl.value);

  const correct = expectedList.length ? expectedList.includes(user) : (normalize(rawExpected) === user);

  const example = cards[current].example ? `<div class="text-sm text-gray-700 mt-1">${cards[current].example}</div>` : "";
  resultEl.innerHTML = `
    <div class="p-2 rounded ${correct ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
      ${correct ? '✅ Correct!' : '❌ Not quite.'}
      <div class="mt-1"><b>${cards[current].front}</b> = ${cards[current].back}</div>
      ${example}
    </div>
  `;
  lastChecked = true;
}

/* Enter key: Check first, then Next */
inputEl.addEventListener("keydown", (ev) => {
  if (ev.key === "Enter") {
    ev.preventDefault();
    if (!lastChecked) {
      checkAnswer();
    } else {
      nextCard();
    }
  }
});
</script>
</body>
</html>
